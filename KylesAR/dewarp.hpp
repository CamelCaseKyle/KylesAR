/*

Dewarp could be made more user friendly
	-load from DistortionGUI generated file
	-hot swapping distortion params
	-re-enable eyebox support
	
	void mainImage( out vec4 fC, in vec2 fX ) {
		//use NDC coords
		vec2 uv = (fX.xy / iResolution.xy) * 2. - 1.;
		uv.y = uv.y * 2. + 1.;
		float eye = 1.;

		//do stereo render
	#ifdef do_stereo
		uv.x *= 2.;
		if (uv.x > 0.) {
			uv.x -= 1.;
			eye = -1.;
		} else {
			uv.x += 1.;
			eye = 1.;
		}
	#endif

		//do distortion correction
		vec2 wrp = getDistortionV3(uv, eye);
		vec2 dlta = uv - wrp;

		fC = vec4(clamp(abs(dlta) * 7., -.8, .8), 0., 1.);
		fC.b = 1.0 - (fC.r*fC.r + fC.g*fC.g);
	
		if (wrp.x < -1. || wrp.x > 1. || wrp.y < -1. || wrp.y > 1.)
			fC = vec4(0.);
    
		//grid pattern
		fC.rgb *= max(.5 * vec3(sign(fract(wrp.x * numSq * .5)-.1) + sign(fract(wrp.y * numSq * .5)-.1)), 0.);
		//fC.rgb *= .5 + .5 * max(vec3(sign(fract(wrp.x * numSq * .25)-.5) * sign(fract(wrp.y * numSq * .25)-.5)), 0.);
	
		//indices of grid
		vec2 uv2 = vec2(floor(wrp.x * numSq * .5), floor(wrp.y * numSq * .5)) / (numSq * .5);
		vec2 wrp2 = getDistortionV3(uv2, eye);
		vec2 dlta2 = uv2 - wrp2;

		//draw diags
		if (dlta2.x * dlta2.y > 0.) {
			float diag = fract(wrp.x * numSq * .5) + fract(wrp.y * numSq * .5) - .5;
			fC.rgb *= 1. - step(.55, diag) * step(diag, .65);
			//fC.rgb *= .8 + .2 * eye;
		} else {
			float diag2 = fract(wrp.x * numSq * .5) - fract(wrp.y * numSq * .5) + .5;
			fC.rgb *= 1. - step(.45, diag2) * step(diag2, .55);
			//fC.rgb *= .8 + .2 * -eye;
		}
    
	
	}
*/

#pragma once

#include <vector>
#include <glm.hpp>

#include "winderps.h"

//eventually load directly from DistortionTools files :D THE BRIDGE
const static glm::vec2 distortionProfile4(const float x, const float x2, const float x3, const float x4, const float y, const float y2, const float y3, const float y4) {
	return glm::vec2(
		        0.027935 +
		x*      1.125561 +
		y*      0.012740 +
		x2*    -0.039869 +
		x*y*    0.124914 +
		y2*     0.002292 +
		x3*    -0.292835 +
		x2*y*  -0.034783 +
		x*y2*  -0.032176 +
		y3*     0.004875 +
		x4*    -0.076597 +
		x3*y*  -0.110877 +
		x2*y2* -0.043108 +
		x*y3*  -0.062561 +
		y4*     0.019749
		,       0.016951 +
		x*      0.012731 +
		y*      1.196121 +
		x2*     0.185902 +
		x*y*   -0.060663 +
		y2*     0.029832 +
		x3*    -0.044401 +
		x2*y*  -0.349245 +
		x*y2*  -0.008731 +
		y3*    -0.212708 +
		x4*    -0.175194 +
		x3*y*  -0.064730 +
		x2*y2* -0.232783 +
		x*y3*   0.054503 +
		y4*    -0.127740
	);
}

//render to this instead of a fullscreen quad
struct DistortionMesh {
	//the data
	std::vector<float> ndCoords, txCoords, txCoords2;
	std::vector<unsigned int> inds;
	//the size of the data so i dont have to compute it every frame
	unsigned int ind_size, coord_size, tx_size;

	DistortionMesh(int rc) {
		ndCoords.clear();
		txCoords.clear();
		inds.clear();
		//rows and columns of grid
		int dr = 32,
			dc = 64;
		//for normalization
		float r, c, stpR = 1.9999999f / float(dr), stpC = 1.9999999f / float(dc);
		//-1 to 1
		for (c = -1.f; c <= 1.f; c += stpC) {
			for (r = -1.f; r <= 1.f; r += stpR) {
				//sample at c,r
				float x2 = c * c, x3 = x2 * c, x4 = x3 * c,
					  y2 = r * r, y3 = y2 * r, y4 = y3 * r,
					  //sample at -c
					  n2 = -c * -c, n3 = n2 * -c, n4 = n3 * -c;
				glm::vec2 res = glm::vec2(c, r) - distortionProfile4(c, x2, x3, x4, r, y2, y3, y4),
						  rs2 = glm::vec2(-c, r) - distortionProfile4(-c, n2, n3, n4, r, y2, y3, y4);
				//verts are from -1 - 1
				ndCoords.push_back(c);
				ndCoords.push_back(r);
				//texCoords are c, r from 0 to 1
				txCoords.push_back((c + res.x) * .5f + .5f);
				txCoords.push_back((r + res.y) * .5f + .5f);
				//now the other eye
				txCoords2.push_back((c - rs2.x) * .5f + .5f);
				txCoords2.push_back((r + rs2.y) * .5f + .5f);
			}
		}
		//calculate indices
		int i, j, r1 = dr + 1;
		//loop through each row
		for (i = 0; i < dc; i++) {
			for (j = 0; j < dr; j++) {
				// upper left
				inds.push_back(i * r1 + j);
				inds.push_back((i + 1) * r1 + j);
				inds.push_back(i * r1 + (j + 1));
				// lower right
				inds.push_back((i + 1) * r1 + j);
				inds.push_back((i + 1) * r1 + (j + 1));
				inds.push_back(i * r1 + (j + 1));
			}
		}
		ind_size = unsigned int(inds.size()) * sizeof(inds[0]);
		coord_size = unsigned int(ndCoords.size()) * sizeof(ndCoords[0]);
		tx_size = unsigned int(txCoords.size()) * sizeof(txCoords[0]);
	}

	void printOBJ() {
		printf("#distortion mesh obj generated by kibbles\n");
		for (int i = 0; i < ndCoords.size(); i += 2)
			printf("v %f %f %f\n", ndCoords[i], ndCoords[i + 1], 0.f);
		for (int i = 0; i < txCoords.size(); i += 2)
			printf("vt %f %f\n", txCoords[i], txCoords[i + 1]);
		for (int i = 0; i < ndCoords.size(); i += 2)
			printf("vn %f %f %f\n", 0., 0., 1.);
		for (int i = 0; i < inds.size(); i += 3)
			printf("f %i/%i/%i %i/%i/%i %i/%i/%i\n", inds[i] + 1, inds[i] + 1, inds[i] + 1, inds[i + 1] + 1, inds[i + 1] + 1, inds[i + 1] + 1, inds[i + 2] + 1, inds[i + 2] + 1, inds[i + 2] + 1);
	}

	// generate unity c#
	void saveOBJ() {
		std::string outp = "//distortion mesh generated by kibbles\n";
		outp += "//num verts:" + to_string(txCoords.size() / 2) + "\n\n";

		outp += "public static Vector3[] verts = new [] {\n";
		for (int i = 0; i < ndCoords.size(); i += 2)
			outp += "\tnew Vector3(" + to_string(ndCoords[i]) + "f, " + to_string(ndCoords[i+1]) + "f, 0.000000f),\n";

		outp += "};\n\npublic static Vector2[] uvsL = new [] {\n";
		for (int i = 0; i < txCoords.size(); i += 2)
			outp += "\tnew Vector2(" + to_string(txCoords[i]) + "f, " + to_string(txCoords[i + 1]) + "f),\n";

		outp += "};\n\npublic static Vector2[] uvsR = new [] {\n";
		for (int i = 0; i < txCoords2.size(); i += 2)
			outp += "\tnew Vector2(" + to_string(txCoords2[i]) + "f, " + to_string(txCoords2[i + 1]) + "f),\n";

		outp += "};\n\npublic static int[] inds = new [] {\n";
		for (int i = 0; i < inds.size(); i += 3)
			outp += "\t" + to_string(inds[i]) + ", " + to_string(inds[i+1]) + ", " + to_string(inds[i+2]) + ",\n";

		outp += "};";

		//opens a text file, dumps string in file
		saveTxt(std::string("dewarp.cs"), outp);
	}
};
