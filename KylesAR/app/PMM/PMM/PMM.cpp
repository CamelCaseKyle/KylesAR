#include "stdafx.h"
#include "PMM.h"

/*super test of PMM
void PMM::map() {
	//if we should save this frame
	std::vector<Mat> plnImgs;
	Mat tmp, outpImg, edges, debug;
	std::string output = "", mtlfile = "";
	plane object = plane(glm::vec3(0.), glm::mat3(0.));
	Point2f midpt = Point2f(cam->rgb.width >> 1, cam->rgb.height >> 1);
	float farthestZ = 0.f;
	int indOffset = 1;

	flip(cam->rgb.frame, outpImg, 1);

#ifdef DO_EDGES
	//get edges
	cvtColor(outpImg, tmp, CV_BGR2GRAY);
	Canny(tmp, edges, 192., 256.);

	//add edges to debug
	cvtColor(edges, debug, CV_GRAY2BGR);
#else
	//no edges
	outpImg.copyTo(debug);
#endif

	//toggle all planes invisible
	for (int i = 0; i < plns.size(); ++i) plns[i].v = false;

	//see if we should save this capture
	bool save = false, s_pressed = waitKey(1) == 's';
	if (s_pressed && !keys['s']) {
		keys['s'] = true;
		save = true;
		output = "# Scene mesh OBJ generated by kibbles\n";
		output += "mtllib PMMcapture.mtl\n";
	}
	else if (!s_pressed) keys['s'] = false;

	std::vector<PositionObject*> poses = scene->getPoses();
	//for each pose
	for (int i = 0; i < poses.size(); ++i) {

#ifdef DBG_SNAP
		if (poses[i]->ID == 31) {
			//attach object
			object.update(glm::vec3(poses[i]->view[3]), glm::mat3(poses[i]->view), poses[i]->visible);
			object.s = glm::vec4(5.f);
			continue;
		}
#endif

		int ind = knownIDs[poses[i]->ID];
		//add or update plane
		if (ind == 0) {
			//one based index because it 0 inits
			knownIDs[poses[i]->ID] = plns.size() + 1;
			plns.push_back(plane(glm::vec3(poses[i]->view[3]), glm::mat3(poses[i]->view)));
			plns.back().s = glm::vec4(poses[i]->size * 10.f);
			plns.back().m = poses[i]->size;
		} else {
			PositionObject* posesi = poses[i];
			if (posesi->visible) plns[ind - 1].update(glm::vec3(posesi->view[3]), glm::mat3(posesi->view), posesi->visible);
		}
	}

#ifdef DO_EDGES
	//generate planes projected into worldspace
	vector<Vec4i> lines;
	std::vector<plane> imgPlns;
	//detect lines
	HoughLinesP(edges, lines, 1, CV_PI / 180., 80, 10, 20);
	//crop around frustrum
	lines.push_back(Vec4i(0, 0, 640, 0));
	lines.push_back(Vec4i(0, 0, 0, 480));
	lines.push_back(Vec4i(640, 480, 640, 0));
	lines.push_back(Vec4i(640, 480, 0, 480));

	//transform lines to 3D planes
	for (int i = 0; i < lines.size(); i++) {
		Point e1 = Point(lines[i][0], lines[i][1]),
			e2 = Point(lines[i][2], lines[i][3]);
		//get midpoint
		Point2f mpt = Point2f(e1 + e2) * .5f;
		Point2f mptNDC = (mpt - midpt) / 640.f;

		//get location on image plane
		glm::vec3 plnLoc = glm::vec3(mptNDC.x, mptNDC.y, 1.f),
			//draw rays from eye to image plane points to form triangle
			p1 = glm::normalize(glm::vec3(e1.x, e1.y, 1.f)),
			p2 = glm::normalize(glm::vec3(e2.x, e2.y, 1.f));

		//compute orthonormal from rd and eye triangle nrm
		glm::mat3 orient = glm::mat3(
			glm::vec3(0.), //will be cross
			glm::normalize(glm::cross(p1, p2)), //nrm
			glm::normalize(plnLoc) //rd
			);
		orient[0] = glm::normalize(glm::cross(orient[1], orient[2]));

		//add and draw
		imgPlns.push_back(plane(plnLoc, orient));
		line(debug, e1, e2, Scalar(0, 255, 0), 1);
	}
#endif

	for (int i = 0; i < plns.size(); ++i) {
		//check vs other planes
		plane& pln = plns[i];
		//dont do anything if it's not visible
		if (!pln.v) continue;

		//trace vs other planes
		for (int j = 0; j < plns.size(); ++j) {
			plane& plnj = plns[j];
			//only check 2 visible planes at once, dont check self
			if (!plnj.v || i == j) continue;
			traceResize(plnj, pln);
		}

#ifdef DO_EDGES
		//trace vs screenspace planes (do not modify screenspace planes)
		for (int j = 0; j < imgPlns.size(); ++j) {
			plane& plnj = plns[j];
			//dot line with screenspace orthonormal to determine if paralol?
			traceResize(pln, plnj);
		}
#endif

		//grab perspective corrected texture and geometry of plane
		if (save) {
			//calculate plane end points (camera space)
			std::vector<glm::vec3> plnp = pln.plnPoints();
			//calc plane points in screen space, perspective, used for perspective transform
			std::vector<Point2f> p = pln.toScreenspace(plnp);
			//get farthest z
			farthestZ = glm::max(farthestZ, -plnp[0].z);
			farthestZ = glm::max(farthestZ, -plnp[1].z);
			farthestZ = glm::max(farthestZ, -plnp[2].z);
			farthestZ = glm::max(farthestZ, -plnp[3].z);

			//get longest edge
			float size = 0.f;
			size = glm::max(size, p[0] | p[1]);
			size = glm::max(size, p[1] | p[2]);
			size = glm::max(size, p[2] | p[3]);
			size = glm::max(size, p[3] | p[0]);
			//how many pixels per centimeter (1/20)
			size *= .05f;
			//for perspective transform to take a snapshot of the plane (for texturing)
			Rect ROI = Rect(0, 0, glm::clamp(size * (pln.s[0] + pln.s[2]), 1.f, 640.f), glm::clamp(size * (pln.s[1] + pln.s[3]), 1.f, 480.f));
			std::vector<Point2f> p2 = {
				Point2f(0.f, 0.f),
				Point2f(ROI.width, 0.f),
				Point2f(ROI.width, ROI.height),
				Point2f(0.f, ROI.height)
			};
			//get perspective (maybe use pln.o)
			Mat M = getPerspectiveTransform(p, p2);
			//add to image collection
			plnImgs.push_back(Mat());
			//warp perspective
			warpPerspective(outpImg, plnImgs.back(), M, ROI.size());

			//copy points to integer point
			std::vector<Point> p3 = {
				Point(p[0].x, p[0].y),
				Point(p[1].x, p[1].y),
				Point(p[2].x, p[2].y),
				Point(p[3].x, p[3].y)
			};
			//cut out plane from final background image
			fillConvexPoly(outpImg, p3, Scalar(1, 1, 1));

			//write to object and material files
			pln.toObj(output, mtlfile, plnp, i, indOffset);
			//offset next group of faces
			indOffset += 4;
		} //if save

		float div = 640.f / pln.l.z;
		//draw center
		Point2f start = Point2f(pln.l.x, pln.l.y) * div + midpt;
		line(debug, start, start, Scalar(255, 255, 255), 7);
		//draw orientation (screen/camera space same because of ortho, single perspective correction because meh)
		Point2f vec = Point2f(pln.o[0].x, pln.o[0].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(255, 0, 0), 3);
		vec = Point2f(pln.o[2].x, pln.o[2].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 0, 255), 3);
		vec = Point2f(pln.o[1].x, pln.o[1].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 255, 0), 3);
		//calc plane points in screen space perspective for debug
		std::vector<Point2f> p = pln.toScreenspace();
		//draw plane outline
		line(debug, p[0], p[1], cols[i]);
		line(debug, p[1], p[2], cols[i]);
		line(debug, p[2], p[3], cols[i]);
		line(debug, p[3], p[0], cols[i]);
	} //for each plane

	if (save) {
		if (farthestZ < 1.0) {
			printf("failed to save\n");
			return;
		}

		plane backdrop = plane(glm::vec3(), glm::mat3());
		float fz640 = farthestZ / 640.f;

		//final backdrop plane with rest of image via inverse perspective transform
		std::vector<glm::vec3> wp = {
			glm::vec3(-midpt.x * fz640, -midpt.y * fz640, -farthestZ),
			glm::vec3(midpt.x * fz640, -midpt.y * fz640, -farthestZ),
			glm::vec3(midpt.x * fz640, midpt.y * fz640, -farthestZ),
			glm::vec3(-midpt.x * fz640, midpt.y * fz640, -farthestZ)
		};
		//add backdrop plane to file, should probably be a sphere section (fovw x fovh) tho
		backdrop.toObj(output, mtlfile, wp, plns.size(), indOffset);

		//output screenspace planes
		//for (int i = 0; i < imgPlns.size(); ++i) {
		//	imgPlns[i].s = glm::vec4(farthestZ, 0, farthestZ, farthestZ);
		//	imgPlns[i].toObj(output, mtlfile, plns.size() + i + 1, indOffset + 4 * (i + 1));
		//}

		//save images to HDD
		for (int i = 0; i < plnImgs.size(); ++i) imwrite("models\\pln" + std::to_string(i) + ".jpg", plnImgs[i]);
		flip(outpImg, outpImg, -1);
		imwrite("models\\pln" + std::to_string(plns.size()) + ".jpg", outpImg);

		//save mesh data to HDD
		std::string filename = "models\\PMMcapture.obj", mtlname = "models\\PMMcapture.mtl";
		saveTxt(filename, output);
		saveTxt(mtlname, mtlfile);

		//tell them it has happened
		printf("Saved %s with %i planes\n", filename.c_str(), plns.size() + 1);
	} //if save

#ifdef DBG_SNAP
	if (object.v) {
		//get closest plane for snapping
		sdresult res = sdresult(zFar, -1);
		for (int i = 0; i < plns.size(); ++i) {
			if (plns[i].v) lt(res, sdresult(plns[i].sd(object.l), i));
		}
		//smooth snap orientation
		if (abs(res.first) < SNAP_DIST && res.second > -1) {
			float percent = glm::clamp((abs(res.first * 2.f) - SNAP_DIST) / SNAP_DIST, 0.f, 1.f);
			//snap orientation
			glm::mat3 newOrient = glm::mat3(
				slerp(plns[res.second].o[0], object.o[0], percent),
				slerp(plns[res.second].o[1], object.o[1], percent),
				slerp(plns[res.second].o[2], object.o[2], percent)
				);
			object.o = newOrient;
			//absolute snap location
			if (percent < .1f) {
				object.l += plns[res.second].o[1] * res.first;
			}
		}

		//draw object locatoin / orientation
		float div = 640.f / object.l.z;
		//draw center
		Point2f start = Point2f(object.l.x, object.l.y) * div + midpt;
		line(debug, start, start, Scalar(255, 255, 255), 7);
		//draw orientation (screen/camera space same because of ortho, single perspective correction because meh)
		Point2f vec = Point2f(object.o[0].x, object.o[0].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(255, 0, 0), 3);
		vec = Point2f(object.o[2].x, object.o[2].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 0, 255), 3);
		vec = Point2f(object.o[1].x, object.o[1].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 255, 0), 3);
	} //if object visible
#endif

	//flip and show image
	flip(debug, debug, 1);
	imshow("PMS", debug);
}
*/

#define DBG_SNAP
//#define DO_EDGES

using namespace cv;

typedef std::pair<float, int> sdresult;

void lt(sdresult& l, sdresult& r) {
	if (abs(r.first) < abs(l.first)) l = r;
}

//construct without orthonormal basis
plane::plane(glm::vec3 pl, glm::vec3 pn) :
	s(glm::vec4(1.f)), l(pl), m(1.f), v(false) {
	//construct orientation using basis
	o = glm::mat3(glm::vec3(0.f), pn + .0001f, glm::vec3(0.f));
	basis(o[1], o[0], o[2]);
}
//construct with orthonormal basis
plane::plane(glm::vec3 pl, glm::mat3 po) :
	o(po), s(glm::vec4(1.f)), l(pl), m(1.f), v(false) {}

//calc plane points in screen space, perspective, used for perspective transform
std::vector<Point2f> plane::_screenspace(std::vector<glm::vec3>& plnPts, Size screensize) {
	Point2f midpt = Point2f(float(screensize.width >> 1), float(screensize.height >> 1));
	float scrwid = float(screensize.width);
	return std::vector<Point2f> {
		Point2f(plnPts[0].x, plnPts[0].y) * (scrwid / plnPts[0].z) + midpt,
			Point2f(plnPts[1].x, plnPts[1].y) * (scrwid / plnPts[1].z) + midpt,
			Point2f(plnPts[2].x, plnPts[2].y) * (scrwid / plnPts[2].z) + midpt,
			Point2f(plnPts[3].x, plnPts[3].y) * (scrwid / plnPts[3].z) + midpt
	};
}
//to obj file
void plane::_obj(std::string& output, std::string& mtlfile, std::vector<glm::vec3>& plnp, int plnNum, int faceIndOffset) {
	//mesh name
	std::string name = "pln" + std::to_string(plnNum);
	//object
	output += "o " + name + "\n";
	//output verts
	output += "v " + std::to_string(plnp[0].x) + " " + std::to_string(plnp[0].y) + " " + std::to_string(plnp[0].z) + "\n";
	output += "v " + std::to_string(plnp[1].x) + " " + std::to_string(plnp[1].y) + " " + std::to_string(plnp[1].z) + "\n";
	output += "v " + std::to_string(plnp[2].x) + " " + std::to_string(plnp[2].y) + " " + std::to_string(plnp[2].z) + "\n";
	output += "v " + std::to_string(plnp[3].x) + " " + std::to_string(plnp[3].y) + " " + std::to_string(plnp[3].z) + "\n";
	//generate UV's
	output += "vt 0.0 1.0\n";
	output += "vt 1.0 1.0\n";
	output += "vt 1.0 0.0\n";
	output += "vt 0.0 0.0\n";
	//normals are just plane normals
	std::string nstr = "vn " + std::to_string(o[1].x) + " " + std::to_string(o[1].y) + " " + std::to_string(o[1].z) + "\n";
	output += nstr + nstr + nstr + nstr;
	//generate shading/texture stuff
	output += "g " + name + "\n";
	output += "usemtl " + name + "\n";
	output += "s " + std::to_string(plnNum + 1) + "\n";
	//generate faces
	std::string f0 = std::to_string(faceIndOffset), f1 = std::to_string(faceIndOffset + 1), f2 = std::to_string(faceIndOffset + 2), f3 = std::to_string(faceIndOffset + 3);
	output += "f " + f0 + "/" + f0 + "/" + f0 + " " + f1 + "/" + f1 + "/" + f1 + " " + f2 + "/" + f2 + "/" + f2 + "\n";
	output += "f " + f0 + "/" + f0 + "/" + f0 + " " + f2 + "/" + f2 + "/" + f2 + " " + f3 + "/" + f3 + "/" + f3 + "\n";
	//generate mtl file
	mtlfile += "newmtl " + name + "\n";
	mtlfile += "Ns 10.0000\n";
	mtlfile += "Ni 1.5000\n";
	mtlfile += "d 1.0000\n";
	mtlfile += "Tr 0.0000\n";
	mtlfile += "Tf 1.0000 1.0000 1.0000\n";
	mtlfile += "illum 2\n";
	mtlfile += "Ka 0.0000 0.0000 0.0000\n";
	mtlfile += "Kd 1.0000 1.0000 1.0000\n";
	mtlfile += "Ks 0.0000 0.0000 0.0000\n";
	mtlfile += "Ke 0.0000 0.0000 0.0000\n";
	mtlfile += "map_Kd " + name + ".jpg\n";
}

//returns signed distance
float plane::sd(glm::vec3 _l) {
	return glm::dot(o[1], l - _l);
}
//returns distance to plane from ro along rd
float plane::rs(glm::vec3 ro, glm::vec3 rd) {
	return glm::dot(o[1], l - ro) / glm::dot(o[1], rd);
}
//returns UV of point on plane
glm::vec2 plane::map(glm::vec3 _l) {
	glm::vec3 r = l - _l;
	return glm::vec2(glm::dot(o[0], r), glm::dot(o[2], r));
}
//returns 3D point from uv on plane
glm::vec3 plane::map(glm::vec2 uv) {
	return l + o[0] * uv.x + o[2] * uv.y;
}

//updates most content
void plane::update(glm::vec3 pl, glm::mat3 po, bool vi) {
	o = po;
	l = pl;
	v = vi;
}
//calculate plane end points (camera space)
std::vector<glm::vec3> plane::plnPoints() {
	glm::vec3 los00 = l + o[0] * s[0],
				los02 = l - o[0] * s[2],
				os21 = o[2] * s[1],
				os23 = o[2] * s[3];
	return std::vector<glm::vec3> { los00 + os21, los00 - os23, los02 - os23, los02 + os21 };
}

//overloads for functions
std::vector<Point2f> plane::toScreenspace(std::vector<glm::vec3>& plnPts, Size screensize) {
	return _screenspace(plnPts, screensize);
}
std::vector<Point2f> plane::toScreenspace(std::vector<glm::vec3>& plnPts) {
	Size screensize = Size(640, 480);
	return _screenspace(plnPts, screensize);
}
std::vector<Point2f> plane::toScreenspace() {
	std::vector<glm::vec3> plnPts = plnPoints();
	Size screensize = Size(640, 480);
	return _screenspace(plnPts, screensize);
}

//overloads for functions
void plane::toObj(std::string& output, std::string& mtlfile, std::vector<glm::vec3>& plnp, int plnNum, int faceIndOffset) {
	_obj(output, mtlfile, plnp, plnNum, faceIndOffset);
}
void plane::toObj(std::string& output, std::string& mtlfile, int plnNum, int faceIndOffset) {
	std::vector<glm::vec3> plnp = plnPoints();
	_obj(output, mtlfile, plnp, plnNum, faceIndOffset);
}
void plane::toObj(std::string& output, std::string& mtlfile) {
	std::vector<glm::vec3> plnp = plnPoints();
	_obj(output, mtlfile, plnp, 1, 1);
}

//initialize things it wont let me init in pmm.h
PMM::PMM() {
	cols = {
		cv::Scalar(255, 128, 128),
		cv::Scalar(128, 255, 128),
		cv::Scalar(128, 128, 255),
		cv::Scalar(128, 255, 255),
		cv::Scalar(255, 128, 255),
		cv::Scalar(255, 255, 128)
	};
	//hard code for now
	info.binding = BIND_HUD;
	info.behavior = HUD_GUI;
}

//traces L against R, only shrinks L
void PMM::traceResize2(plane& l, plane& r) {
	//raytrace ortho +-X and +-Z
	float l2px = r.rs(l.l, l.o[0]), l2pz = r.rs(l.l, l.o[2]);
	if (abs(l2px) < zFar) {
		//if the ray hit 'in front of' ro
		if (l2px > 0.f) l.s[0] = glm::min(l.s[0], glm::max(l.m, l2px));
		else l.s[2] = glm::min(l.s[2], glm::max(l.m, -l2px));
	}
	if (abs(l2pz) < zFar) {
		if (l2pz > 0.f) l.s[1] = glm::min(l.s[1], glm::max(l.m, l2pz));
		else l.s[3] = glm::min(l.s[3], glm::max(l.m, -l2pz));
	}
}
//traces L against R, resizes L
void PMM::traceResize(plane& l, plane& r) {
	//raytrace ortho +-X and +-Z
	float l2px = r.rs(l.l, l.o[0]), l2pz = r.rs(l.l, l.o[2]);
	if (abs(l2px) < zFar) {
		//if the ray hit 'in front of' ro
		if (l2px > 0.f) l.s[0] = glm::max(l.m, l2px);
		else l.s[2] = glm::max(l.m, -l2px);
	}
	if (abs(l2pz) < zFar) {
		if (l2pz > 0.f) l.s[1] = glm::max(l.m, l2pz);
		else l.s[3] = glm::max(l.m, -l2pz);
	}
}

//save the PMM state
void PMM::map() {
	//Mat outpImg;
	std::string output = "# Scene mesh OBJ generated by kibbles\nmtllib PMMcapture.mtl\n", mtlfile = "";
	float farthestZ = 0.f;
	int indOffset = 1;

	//using debug
	//flip(cam->rgb.frame, outpImg, 1);

	for (int i = 0; i < plns.size(); ++i) {
		//check vs other planes
		plane& pln = plns[i];
		//dont do anything if it's not visible
		if (!pln.v) continue;

		//calculate plane end points (camera space)
		std::vector<glm::vec3> plnp = pln.plnPoints();
		//calc plane points in screen space, perspective, used for perspective transform
		std::vector<Point2f> p = pln.toScreenspace(plnp);
		//get farthest z
		farthestZ = glm::max(farthestZ, -plnp[0].z);
		farthestZ = glm::max(farthestZ, -plnp[1].z);
		farthestZ = glm::max(farthestZ, -plnp[2].z);
		farthestZ = glm::max(farthestZ, -plnp[3].z);

		//copy points to integer point
		std::vector<Point> p3 = {
			Point(int(p[0].x), int(p[0].y)),
			Point(int(p[1].x), int(p[1].y)),
			Point(int(p[2].x), int(p[2].y)),
			Point(int(p[3].x), int(p[3].y))
		};
		//cut out plane from final background image
		fillConvexPoly(debug, p3, Scalar(1, 1, 1));

		//write to object and material files
		pln.toObj(output, mtlfile, plnp, i, indOffset);
		//offset next group of faces
		indOffset += 4;
	} //for each plane

	if (farthestZ < 1.0) {
		printf("failed to save\n");
		return;
	}

	plane backdrop = plane(glm::vec3(), glm::mat3());
	float fz640 = farthestZ / 640.f;

	//final backdrop plane with rest of image via inverse perspective transform
	std::vector<glm::vec3> wp = {
		glm::vec3(-midpt.x * fz640, -midpt.y * fz640, -farthestZ),
		glm::vec3(midpt.x * fz640, -midpt.y * fz640, -farthestZ),
		glm::vec3(midpt.x * fz640, midpt.y * fz640, -farthestZ),
		glm::vec3(-midpt.x * fz640, midpt.y * fz640, -farthestZ)
	};
	//add backdrop plane to file, should probably be a sphere section (fovw x fovh) tho
	backdrop.toObj(output, mtlfile, wp, int(plns.size()), indOffset);

	//output screenspace planes
	//for (int i = 0; i < imgPlns.size(); ++i) {
	//	imgPlns[i].s = glm::vec4(farthestZ, 0, farthestZ, farthestZ);
	//	imgPlns[i].toObj(output, mtlfile, plns.size() + i + 1, indOffset + 4 * (i + 1));
	//}

	//save images to HDD
	for (int i = 0; i < plnImgs.size(); ++i) imwrite("models\\pln" + std::to_string(i) + ".jpg", plnImgs[i]);
	flip(debug, debug, -1);
	imwrite("models\\pln" + std::to_string(plnImgs.size()) + ".jpg", debug);

	//save mesh data to HDD
	std::string filename = "models\\PMMcapture.obj", mtlname = "models\\PMMcapture.mtl";
	saveTxt(filename, output);
	saveTxt(mtlname, mtlfile);

	//tell them it has happened
	printf("Saved %s with %i planes\n", filename.c_str(), plns.size() + 1);
}
//update plnImgs textures
void PMM::texture() {
	for (int i = 0; i < plns.size(); ++i) {
		//check vs other planes
		plane& pln = plns[i];
		//dont do anything if it's not visible
		if (!pln.v) continue;

		//calc plane points in screen space, perspective, used for perspective transform
		std::vector<Point2f> p = pln.toScreenspace();

		//get longest edge
		float size = 0.f;
		size = glm::max(size, p[0] | p[1]);
		size = glm::max(size, p[1] | p[2]);
		size = glm::max(size, p[2] | p[3]);
		size = glm::max(size, p[3] | p[0]);
		//how many pixels per centimeter (1/20)
		size *= .05f;
		//for perspective transform to take a snapshot of the plane (for texturing)
		float rtw = glm::clamp(size * (pln.s[0] + pln.s[2]), 1.f, 640.f),
			rth = glm::clamp(size * (pln.s[1] + pln.s[3]), 1.f, 480.f);
		
		//do a per pixel plot of density and replace pixel for pixel
		std::vector<Point2f> p2 = {
			Point2f(0.f, 0.f),
			Point2f(rtw, 0.f),
			Point2f(rtw, rth),
			Point2f(0.f, rth)
		};

		//get perspective (maybe use pln.o)
		Mat M = getPerspectiveTransform(p, p2);
		//warp perspective
		warpPerspective(plnImgs[i], plnImgs.back(), M, Size(int(rtw), int(rth)));
	}
}

//add to scene callback
void PMM::sceneCallback(Scene* _scene, Context* renderer) {
	cam = _scene->getCamera();
	scene = _scene;
	if (cam == nullptr) return;
	midpt = cv::Point2f(float(cam->rgb.width >> 1), float(cam->rgb.height >> 1));
}
//bind to parent callback
void PMM::bindCallback(PositionObject* parent) {}
//remove from scene callback
void PMM::removeCallback() {
	cam = nullptr;
	scene = nullptr;
}

//update the planes with image processing and tracing
void PMM::update() {
	if (scene == nullptr) return;

	//toggle all planes invisible
	for (int i = 0; i < plns.size(); ++i)
		plns[i].v = false;

	std::vector<PositionObject*> poses = scene->getPoses();
	//for each pose
	for (int i = 0; i < poses.size(); ++i) {

#ifdef DBG_SNAP
		if (poses[i]->ID == 31) {
			//attach object
			object.update(glm::vec3(poses[i]->view[3]), glm::mat3(poses[i]->view), poses[i]->visible);
			object.s = glm::vec4(5.f);
			continue;
		}
#endif

		int ind = knownIDs[poses[i]->ID];
		//add or update plane
		if (ind == 0) {
			//one based index because it 0 inits
			knownIDs[poses[i]->ID] = int(plns.size()) + 1;
			plns.push_back(plane(glm::vec3(poses[i]->view[3]), glm::mat3(poses[i]->view)));
			plns.back().s = glm::vec4(poses[i]->size * 10.f);
			plns.back().m = poses[i]->size;
			plnImgs.push_back(Mat());
		} else {
			PositionObject* posesi = poses[i];
			if (posesi->visible) plns[ind - 1].update(glm::vec3(posesi->view[3]), glm::mat3(posesi->view), posesi->visible);
		}
	}

#ifdef DO_EDGES
	//generate planes projected into worldspace
	vector<Vec4i> lines;
	std::vector<plane> imgPlns;
	//detect lines
	HoughLinesP(edges, lines, 1, CV_PI / 180., 80, 10, 20);
	//crop around frustrum
	lines.push_back(Vec4i(0, 0, 640, 0));
	lines.push_back(Vec4i(0, 0, 0, 480));
	lines.push_back(Vec4i(640, 480, 640, 0));
	lines.push_back(Vec4i(640, 480, 0, 480));

	//transform lines to 3D planes
	for (int i = 0; i < lines.size(); i++) {
		Point e1 = Point(lines[i][0], lines[i][1]),
			e2 = Point(lines[i][2], lines[i][3]);
		//get midpoint
		Point2f mpt = Point2f(e1 + e2) * .5f;
		Point2f mptNDC = (mpt - midpt) / 640.f;

		//get location on image plane
		glm::vec3 plnLoc = glm::vec3(mptNDC.x, mptNDC.y, 1.f),
			//draw rays from eye to image plane points to form triangle
			p1 = glm::normalize(glm::vec3(e1.x, e1.y, 1.f)),
			p2 = glm::normalize(glm::vec3(e2.x, e2.y, 1.f));

		//compute orthonormal from rd and eye triangle nrm
		glm::mat3 orient = glm::mat3(
			glm::vec3(0.), //will be cross
			glm::normalize(glm::cross(p1, p2)), //nrm
			glm::normalize(plnLoc) //rd
		);
		orient[0] = glm::normalize(glm::cross(orient[1], orient[2]));

		//add and draw
		imgPlns.push_back(plane(plnLoc, orient));
		line(debug, e1, e2, Scalar(0, 255, 0), 1);
	}
#endif

	for (int i = 0; i < plns.size(); ++i) {
		//check vs other planes
		plane& pln = plns[i];
		//dont do anything if it's not visible
		if (!pln.v) continue;

		//trace vs other planes
		for (int j = 0; j < plns.size(); ++j) {
			plane& plnj = plns[j];
			//only check 2 visible planes at once, dont check self
			if (!plnj.v || i == j) continue;
			traceResize(plnj, pln);
		}

#ifdef DO_EDGES
		//trace vs screenspace planes (do not modify screenspace planes)
		for (int j = 0; j < imgPlns.size(); ++j) {
			plane& plnj = imgPlns[j];
			//dot line with screenspace orthonormal to determine if paralol?
			traceResize(pln, plnj);
		}
#endif
		
	}

#ifdef DBG_SNAP
	if (object.v) {
		//get closest plane for snapping
		sdresult res = sdresult(zFar, -1);
		for (int i = 0; i < plns.size(); ++i) {
			if (plns[i].v) lt(res, sdresult(plns[i].sd(object.l), i));
		}
		//smooth snap orientation
		if (abs(res.first) < SNAP_DIST && res.second > -1) {
			float percent = glm::clamp((abs(res.first * 2.f) - SNAP_DIST) / SNAP_DIST, 0.f, 1.f);
			//snap orientation
			glm::mat3 newOrient = glm::mat3(
				slerp(plns[res.second].o[0], object.o[0], percent),
				slerp(plns[res.second].o[1], object.o[1], percent),
				slerp(plns[res.second].o[2], object.o[2], percent)
			);
			object.o = newOrient;
			//absolute snap location
			if (percent < .1f) {
				object.l += plns[res.second].o[1] * res.first;
			}
		}

		//draw object locatoin / orientation
		float div = 640.f / object.l.z;
		//draw center
		Point2f start = Point2f(object.l.x, object.l.y) * div + midpt;
		line(debug, start, start, Scalar(255, 255, 255), 7);
		//draw orientation (screen/camera space same because of ortho, single perspective correction because meh)
		Point2f vec = Point2f(object.o[0].x, object.o[0].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(255, 0, 0), 3);
		vec = Point2f(object.o[2].x, object.o[2].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 0, 255), 3);
		vec = Point2f(object.o[1].x, object.o[1].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 255, 0), 3);
	} //if object visible
#endif

	//update plane textures
	texture();
}
//render the debug display
void PMM::render() {
	if (cam == nullptr) return;
	flip(cam->rgb.frame, debug, 1);
	for (int i = 0; i < plns.size(); ++i) {
		//check vs other planes
		plane& pln = plns[i];
		//dont do anything if it's not visible
		if (!pln.v) continue;

		float div = 640.f / pln.l.z;
		//draw center
		Point2f start = Point2f(pln.l.x, pln.l.y) * div + midpt;
		line(debug, start, start, Scalar(255, 255, 255), 7);
		//draw orientation (screen/camera space same because of ortho, single perspective correction because meh)
		Point2f vec = Point2f(pln.o[0].x, pln.o[0].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(255, 0, 0), 3);
		vec = Point2f(pln.o[2].x, pln.o[2].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 0, 255), 3);
		vec = Point2f(pln.o[1].x, pln.o[1].y) * div;
		line(debug, start, start + vec * 5.f, Scalar(0, 255, 0), 3);
		//calc plane points in screen space perspective for debug
		std::vector<Point2f> p = pln.toScreenspace();
		//draw plane outline
		line(debug, p[0], p[1], cols[i]);
		line(debug, p[1], p[2], cols[i]);
		line(debug, p[2], p[3], cols[i]);
		line(debug, p[3], p[0], cols[i]);
	}
	//flip and show image
	//flip(debug, debug, 1);
	//imshow("PMS", debug);
}
